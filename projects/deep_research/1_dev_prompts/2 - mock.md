# Mocking the experience
Before we move to actually implement/integrate this into the Hermes codebase, let's make a mock interface, where the user plays the assistant role.
I will be the user. It will be a python application without reliance on any 3rd party libraries.
When I start the application, I'll be provided with help content, standard instructions, and the problem that is given to me (currently we'll hardcode, as we are mocking the actual user's inputs).
I won't see the files themselves and won't see any mention that these are files.
We build an abstraction over the file system.

The goal of this exercise is to build the file system abstraction while mocking the actual user-llm interactions.

The assistant will have its own way to finish a message, but in this mock case, we'll use multiline input with escape + enter to finish typing.
Any message that is finished without Done command will be replied with an automatic message asking to continue the investigation.

The assistant can either use one of the operations, or just think or write drafts.

## Operations
I'll have the below operations.

### Add criteria
Given the problem definition, add criteria for the definition of done.
Maybe we found new information which shows that to mark this task as done we need to have more things answered.

### Add subproblems
Based on new findings we add new subproblems so that we meet the criteria and solve the current problem.
New subproblem includes a title and a problem definition.
Breakdown structure is simply the combination of the title + problem definition of all subproblems of the current problem.

### Add attachments
For this we'll have special commands, to open URL, a file, etc, which will be saved into the attachments folder.

### Write report 3-pager
This report is essential part to finish the current problem at focus, as this information will be visible to the parent problem. And from the parent problem we'll be able to use this 3-pager to solve that problem. We should make sure this includes all the important details that are necessary to solve the parent problems. The document should be maximum 3 pages long.
There should be a structure in the document. It works backwards from the provided problem, asking a question about it, answering, then recursively going deeper and deeper, while also covering breadth (there can be multiple questions about the same topic to answer). This structure is essential to both include all the relevant details, but also to include why these details are relevant.

The format should be:
Summarized problem definition: ...
Q1: ...
A1: ...
Q1.1: ...
A1.1: ...
Q1.1.1: ...
...
Q1.2: ...
...
Q2: ...
Conclusion: ...

Each of these blocks can be multiline, include as much details as needed, use code blocks, markdown structures, tables, etc.

### Focus down
Choose a subproblem that becomes the current focus point.
The history gets cleaned up, we see all the problems, criteria and problem breakdowns in the parent line. We see the current problem of the active node.
It's a clean start to focus on the current problem.

### Focus up
Go back up to the parent problem. It becomes the current focus point.
The history similarly gets cleaned up, but we now also see this subproblem 3-pager report.
No previous history is visible. We look at the problem freshly considering all the current findings.

## Operations input
As the interface will be textual, the commands will be executed as special tokens in the response.

Commands without arguments with have `///command_name` format, no spaces.
If they accept one line argument, the argument can be placed next to it: `///command_name arg1 arg2 arg3...`

If the command accepts multiline arguments, we wrap the command into a command block. Inside it we have sections for the individual arguments, each of which is treated as multiline.
```
<<<<< command_name
///title
title goes here
///content
content line 1
content line 2
content line 3
///some_other_argument
more content
more lines
>>>>>
```

## File system
The file system gets updated in the background, without being shown to the assistant.

The format will be:

- Folder with name matching the problem title. For root problem the folder is provided by the user.
-- Problem Definition.md
-- Criteria of Definition of Done.md
-- Breakdown Structure.md (autogenerated based on subproblems)
-- Attachments/{Attachment Name}.md (all url/file attachments get loaded here)
-- Subproblems/{subproblem title}/ (same structure, iteratively)
-- Report 3 Pager.md

The file system needs to be updated after every interaction (update the impacted files, create new directories for subproblems with their own structures).

### If when the process starts the folder already exists
This means that we are continuing something that was left partial before.
The assistant might be given with new instructions to modify the requirements, etc.

## Interface

### Problem defined
```
# Deep Research Interface

; information about the interface
; simple commands
; block commands
; explain hierarchy between problems, what parent problems chain means (or better term, etc)
; explain how the chat history will be erased with every focus change, as it's a new beginning
; explain to use the commands symbol by symbol correctly
; explain that only the attachments of the current problem are visible, so when changing focus the attachments will change as well

## Simple Commands
- ///add_criteria Your criteria text here
- ///mark_criteria_as_done criteria_index
- ///focus_down Subproblem Title
- ///focus_up (when done with the subproblem, focus up)
- ///finish_task (visible only when at the root task)

## Block Commands
\```
<<<<< add_subproblem
///title
Subproblem Title
///content
Problem definition goes here
>>>>>
\```

\```
<<<<< add_attachment
///name
attachment_name.txt
///content
Content goes here
>>>>>
\```

\```
<<<<< write_report
///content
Report content goes here
>>>>>
\```

\```
<<<<< append_to_problem_definition
///content
Content to append to the problem definition.
>>>>>
\```
This might be needed if the direction needs to be adjusted based on user input.

======================
# Attachments Of Current Problem

<attachments>
<attachment name="http://....">
The content goes here...
</attachment>
...
</attachments>

======================
# Instruction
The user will provide an instruction before the deep research starts. This instruction will always remain visible here.

======================
# Current Problem: {title}

## Problem Hierarchy
 └── Root: {title}
     └── Level 1: {title} [{x}/{y} criteria met]
         └── CURRENT: {current title}

## Problem Definition
{problem definition}

## Criteria of Definition of Done
{list of criteria with their indices}

## Breakdown Structure
### {subproblem title}
{subproblem definition}

## Parent chain
### L0 Root Problem: {title}
{problem definition}
#### L0 Problem Breakdown Structure
##### {subproblem title}
{subproblem definition}
...
### L1 Problem {title}
...

## Goal
; A comment explaining that the goal is to move forward on the current problem, modify, add subproblems as needed. Should be generic comment, that will be same regardless of what problem currently I work on. The purpose is to have closure of the message reminding what the action should be.
Your task is to continue investigating the current problem on {title}. Add criteria if needed, create subproblems to structure your investigation, and work toward producing a comprehensive 3-page report. Use the attachments for reference and add new ones as needed. When ready to move to a different focus area, use the focus commands.
```

### No problem defined
```
# Deep Research Interface

; information about the interface
; explain the standards and best practices for defining a problem
; explain that this is a temporary state and that this chat will be discarded after defining the problem and the assistant will start working on the problem
; explain that current attachments will be copied to the root problem after creation and won't be lost

======================
# Attachments
; these are the attachments user has included to use while creating the problem
; these attachments will be copied to the root problem after creation

<attachments>
<attachment name="http://....">
The content goes here...
</attachment>
...
</attachments>

======================
# Instruction
The user will provide an instruction before the deep research starts. This instruction will always remain visible here.

======================
# How to define a problem
Define the problem using this command:
\```
<<<<< define_problem
///title
title goes here
///content
Content of the problem definition.
>>>>>
\```
```
