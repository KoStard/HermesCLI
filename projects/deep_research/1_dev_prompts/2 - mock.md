# Mocking the experience
Before we move to actually implement/integrate this into the Hermes codebase, let's make a mock interface, where the user plays the assistant role.
I will be the user. It will be a python application without reliance on any 3rd party libraries.
When I start the application, I'll be provided with help content, standard instructions, and the problem that is given to me (currently we'll hardcode, as we are mocking the actual user's inputs).
I won't see the files themselves and won't see any mention that these are files.
We build an abstraction over the file system.

The goal of this exercise is to build the file system abstraction while mocking the actual user-llm interactions.

The assistant will have its own way to finish a message, but in this mock case, we'll use multiline input with escape + enter to finish typing.
Any message that is finished without Done command will be replied with an automatic message asking to continue the investigation.

The assistant can either use one of the operations, or just think or write drafts.

## Operations
I'll have the below operations.

### Add criteria
Given the problem definition, add criteria for the definition of done.
Maybe we found new information which shows that to mark this task as done we need to have more things answered.

### Add criteria to subproblem
Add criteria to a specific **subproblem** by title. This is useful when new information is found that requires revisiting a subproblem with additional requirements.

### Add subproblems
Based on new findings we add new subproblems so that we meet the criteria and solve the current problem.
New subproblem includes a title and a problem definition.
Breakdown structure is simply the combination of the title + problem definition of all subproblems of the current problem, along with the criteria completion status (e.g., "[2/5 criteria met]").

### Add attachments
For this we'll have special commands, to open URL, a file, etc, which will be saved into the attachments folder.

### Write report 3-pager
This report is essential part to finish the current problem at focus, as this information will be visible to the parent problem. And from the parent problem we'll be able to use this 3-pager to solve that problem. We should make sure this includes all the important details that are necessary to solve the parent problems. The document should be maximum 3 pages long.
There should be a structure in the document. It works backwards from the provided problem, asking a question about it, answering, then recursively going deeper and deeper, while also covering breadth (there can be multiple questions about the same topic to answer). This structure is essential to both include all the relevant details, but also to include why these details are relevant.

Before writing the 3-page report, ensure all criteria are met and marked as done. This ensures your report is comprehensive and addresses all required aspects of the problem.

The format should be:
Summarized problem definition: ...
Q1: ...
A1: ...
Q1.1: ...
A1.1: ...
Q1.1.1: ...
...
Q1.2: ...
...
Q2: ...
Conclusion: ...

Each of these blocks can be multiline, include as much details as needed, use code blocks, markdown structures, tables, etc.

### Focus down
Choose a subproblem that becomes the current focus point.
The history gets cleaned up, we see all the problems, criteria and problem breakdowns in the parent line. We see the current problem of the active node.
It's a clean start to focus on the current problem.

### Focus up
Go back up to the parent problem. It becomes the current focus point.
The history similarly gets cleaned up, but we now also see this subproblem 3-pager report.
No previous history is visible. We look at the problem freshly considering all the current findings.

## Operations input
As the interface will be textual, the commands will be executed as special tokens in the response.

Commands without arguments with have `///command_name` format, no spaces.
If they accept one line argument, the argument can be placed next to it: `///command_name arg1 arg2 arg3...`

If the command accepts multiline arguments, we wrap the command into a command block. Inside it we have sections for the individual arguments, each of which is treated as multiline.
```
<<< command_name
///title
title goes here
///content
content line 1
content line 2
content line 3
///some_other_argument
more content
more lines
>>>
```

For the add_criteria_to_subproblem command, the format is:
```
<<< add_criteria_to_subproblem
///title
Subproblem Title
///criteria
Your criteria text here (should be a single line)
>>>
```

## File system
The file system gets updated in the background, without being shown to the assistant.

The format will be:

- Folder with name matching the problem title. For root problem the folder is provided by the user.
-- Problem Definition.md
-- Criteria of Definition of Done.md
-- Breakdown Structure.md (autogenerated based on subproblems)
-- Attachments/{Attachment Name}.md (all url/file attachments get loaded here)
-- Subproblems/{subproblem title}/ (same structure, iteratively)
-- Report 3 Pager.md

The file system needs to be updated after every interaction (update the impacted files, create new directories for subproblems with their own structures).

### If when the process starts the folder already exists
This means that we are continuing something that was left partial before.
The assistant might be given with new instructions to modify the requirements, etc.

## Interface

### Problem defined
```
# Deep Research Interface

## Introduction

; information about the interface
; information about errors handling of the commands, to check "Errors report" and "Execution Status Report" in the response
; explain how the chat history will be erased with every focus change, as it's a new beginning
; explain that the commands should be the first things in the line
; escape code: if for whatever reason the tool has issues and you are not able to focus up, finish the task or to navigate, just type SHUT_DOWN_DEEP_RESEARCHER anywhere in your response and the system will stop
; explain hierarchy between problems, what parent problems chain means (or better term, etc). discourage too many children.
; explain to use the commands symbol by symbol correctly
; explain that only the attachments of the current problem and all parents are visible, so when changing focus the attachments will change as well
; explain that only one focus change is allowed in one response
; explain that the focus change command should be the last command in the message, after changing focus there will be new session, so it marks the end of the current session. Terminate the message afterwards.
; add warning about resolving criteria before writing 3-pagers
; provide guidelines on how to write a report, expectations on the length

## Block Commands
; add_criteria Your criteria text here
; mark_criteria_as_done criteria_number ; explain that this works only for the current node
; focus_down Subproblem Title
; focus_up (when done with the subproblem, focus up. when in root task, will finish the task)
; fail_task_and_focus_up (if for some reason the current task can't be resolved at all, and you want to mark it as failed, use this)
; add_subproblem multiline block information - title and content arguments (sanitize title to have only one line, replace \n with space)
; add_attachment multiline block information - name and content - name should have one line
; write_report multiline block information - content
; append_to_problem_definition multiline block information - content
; add_criteria_to_subproblem - subtask title, criteria
; example:
; \```
; <<< add_subproblem
; ///title
; Subproblem Title
; ///content
; Problem definition goes here
; >>>
; \```

======================
# Attachments Of Current Problem

<attachments>
<attachment name="http://....">
The content goes here...
</attachment>
...
</attachments>

======================
# Context
; before starting the session, the user will provide some context, these can be just text chunks or attachments. These will be permanently present and won't change when changing focus
<contextAttachments>
<contextAttachment>
...
</contextAttachment>
...
</contextAttachments>

======================
# Instruction
; The user will provide an instruction before the deep research starts. This instruction will always remain visible here.

======================
# Current Problem: {title}

## Problem Hierarchy
 └── Root: {title}
     └── Level 1: {title} [{x}/{y} criteria met]
         └── CURRENT: {current title}

## Problem Definition
{problem definition}

## Criteria of Definition of Done
{list of criteria with their numbers and completion status (e.g., "[✓]" or "[ ]")}

## Breakdown Structure
### {subproblem title}
{subproblem definition}

## Completed Reports

### Child Reports
#### {subproblem title}
{3-pager report content for completed child subproblems}

### Current Report
{3-pager report content for current node if it exists}

## Parent chain
### L0 Root Problem: {title}
{problem definition}
#### L0 Problem Breakdown Structure
##### {subproblem title}
{subproblem definition}
...
### L1 Problem {title}
...

## Goal
; A comment explaining that the goal is to move forward on the current problem, modify, add subproblems as needed. Should be generic comment, that will be same regardless of what problem currently I work on. The purpose is to have closure of the message reminding what the action should be.
```

### No problem defined
```
# Deep Research Interface

; information about the interface
; information about errors handling of the commands, to check "Errors report" and "Execution Status Report" in the response
; explain the standards and best practices for defining a problem
; explain that this is a temporary state and that this chat will be discarded after defining the problem and the assistant will start working on the problem
; explain that current attachments will be copied to the root problem after creation and won't be lost
; explain that there is also some context provided, this will be available in all the upcoming sessions, so you can refer to it if needed
; explain that only one problem definition is allowed
; explain that closing tags are mandatory for command blocks, otherwise it will break the parsing

======================
# Attachments
; these are the attachments user has included to use while creating the problem
; these attachments will be copied to the root problem after creation

<attachments>
<attachment name="http://....">
The content goes here...
</attachment>
...
</attachments>

======================
# Context
; before starting the session, the user will provide some context, these can be just text chunks or attachments. These will be permanently present and won't change when changing focus
<contextAttachments>
<contextAttachment>
...
</contextAttachment>
...
</contextAttachments>

======================
# Instruction
; The user will provide an instruction before the deep research starts. This instruction will always remain visible here.

======================
# How to define a problem
Define the problem using this command:
\```
<<< define_problem
///title
title goes here
///content
Content of the problem definition.
>>>
\```
```
